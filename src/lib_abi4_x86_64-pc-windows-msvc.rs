/* automatically generated by rust-bindgen 0.69.5 */

pub type cec_menu_language = [::std::os::raw::c_char; 4usize];
pub type cec_osd_name = [::std::os::raw::c_char; 14usize];
pub type libcec_connection_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cec_log_message {
    #[doc = "< the actual message, valid until returning from the log callback"]
    pub message: *const ::std::os::raw::c_char,
    #[doc = "< log level of the message"]
    pub level: cec_log_level,
    #[doc = "< the timestamp of this message"]
    pub time: i64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cec_keypress {
    #[doc = "< the keycode"]
    pub keycode: cec_user_control_code,
    #[doc = "< the duration of the keypress"]
    pub duration: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cec_adapter {
    #[doc = "< the path to the com port"]
    pub path: [::std::os::raw::c_char; 1024usize],
    #[doc = "< the name of the com port"]
    pub comm: [::std::os::raw::c_char; 1024usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cec_adapter_descriptor {
    #[doc = "< the path to the com port"]
    pub strComPath: [::std::os::raw::c_char; 1024usize],
    #[doc = "< the name of the com port"]
    pub strComName: [::std::os::raw::c_char; 1024usize],
    pub iVendorId: u16,
    pub iProductId: u16,
    pub iFirmwareVersion: u16,
    pub iPhysicalAddress: u16,
    pub iFirmwareBuildDate: u32,
    pub adapterType: cec_adapter_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cec_datapacket {
    #[doc = "< the actual data"]
    pub data: [u8; 64usize],
    #[doc = "< the size of the data"]
    pub size: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cec_command {
    #[doc = "< the logical address of the initiator of this message"]
    pub initiator: cec_logical_address,
    #[doc = "< the logical address of the destination of this message"]
    pub destination: cec_logical_address,
    #[doc = "< 1 when the ACK bit is set, 0 otherwise"]
    pub ack: i8,
    #[doc = "< 1 when the EOM bit is set, 0 otherwise"]
    pub eom: i8,
    #[doc = "< the opcode of this message"]
    pub opcode: cec_opcode,
    #[doc = "< the parameters attached to this message"]
    pub parameters: cec_datapacket,
    #[doc = "< 1 when an opcode is set, 0 otherwise (POLL message)"]
    pub opcode_set: i8,
    #[doc = "< the timeout to use in ms"]
    pub transmit_timeout: i32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cec_device_type_list {
    #[doc = "< the list of device types"]
    pub types: [cec_device_type; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cec_logical_addresses {
    #[doc = "< the primary logical address to use"]
    pub primary: cec_logical_address,
    #[doc = "< the list of addresses"]
    pub addresses: [::std::os::raw::c_int; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libcec_parameter {
    #[doc = "< the type of this parameter"]
    pub paramType: libcec_parameter_type,
    #[doc = "< the value of this parameter"]
    pub paramData: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cec_adapter_stats {
    pub tx_ack: ::std::os::raw::c_uint,
    pub tx_nack: ::std::os::raw::c_uint,
    pub tx_error: ::std::os::raw::c_uint,
    pub rx_total: ::std::os::raw::c_uint,
    pub rx_error: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ICECCallbacks {
    #[doc = " @brief Transfer a log message from libCEC to the client.\n @param cbparam             Callback parameter provided when the callbacks were set up\n @param message             The message to transfer."]
    pub logMessage: ::std::option::Option<
        unsafe extern "C" fn(cbparam: *mut ::std::os::raw::c_void, message: *const cec_log_message),
    >,
    #[doc = " @brief Transfer a keypress from libCEC to the client.\n @param cbparam             Callback parameter provided when the callbacks were set up\n @param key                 The keypress to transfer."]
    pub keyPress: ::std::option::Option<
        unsafe extern "C" fn(cbparam: *mut ::std::os::raw::c_void, key: *const cec_keypress),
    >,
    #[doc = " @brief Transfer a CEC command from libCEC to the client.\n @param cbparam             Callback parameter provided when the callbacks were set up\n @param command             The command to transfer."]
    pub commandReceived: ::std::option::Option<
        unsafe extern "C" fn(cbparam: *mut ::std::os::raw::c_void, command: *const cec_command),
    >,
    #[doc = " @brief Transfer a changed configuration from libCEC to the client\n @param cbparam             Callback parameter provided when the callbacks were set up\n @param configuration       The configuration to transfer"]
    pub configurationChanged: ::std::option::Option<
        unsafe extern "C" fn(
            cbparam: *mut ::std::os::raw::c_void,
            configuration: *const libcec_configuration,
        ),
    >,
    #[doc = " @brief Transfer a libcec alert message from libCEC to the client\n @param cbparam             Callback parameter provided when the callbacks were set up\n @param alert               The alert type transfer.\n @param data                Misc. additional information."]
    pub alert: ::std::option::Option<
        unsafe extern "C" fn(
            cbparam: *mut ::std::os::raw::c_void,
            alert: libcec_alert,
            param: libcec_parameter,
        ),
    >,
    #[doc = " @brief Transfer a menu state change to the client.\n Transfer a menu state change to the client. If the command returns 1, then the change will be processed by\n the busdevice. If 0, then the state of the busdevice won't be changed, and will always be kept 'activated',\n @warning CEC does not allow the player to suppress the menu state change on the TV, so the menu on the TV will always be displayed, whatever the return value of this method is.\n so keypresses are always routed.\n @param cbparam             Callback parameter provided when the callbacks were set up\n @param state               The new value.\n\n @return 1 if libCEC should use this new value, 0 otherwise."]
    pub menuStateChanged: ::std::option::Option<
        unsafe extern "C" fn(
            cbparam: *mut ::std::os::raw::c_void,
            state: cec_menu_state,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " @brief Called when a source that's handled by this client is activated.\n @param cbparam             Callback parameter provided when the callbacks were set up\n @param logicalAddress      The address that was just activated.\n @param bActivated          1 if activated, 0 when deactivated."]
    pub sourceActivated: ::std::option::Option<
        unsafe extern "C" fn(
            cbParam: *mut ::std::os::raw::c_void,
            logicalAddress: cec_logical_address,
            bActivated: u8,
        ),
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct libcec_configuration {
    #[doc = "< the version of the client that is connecting"]
    pub clientVersion: u32,
    #[doc = "< the device name to use on the CEC bus, name + 0 terminator"]
    pub strDeviceName: [::std::os::raw::c_char; 13usize],
    #[doc = "< the device type(s) to use on the CEC bus for libCEC"]
    pub deviceTypes: cec_device_type_list,
    #[doc = "< (read only) set to 1 by libCEC when the physical address was autodetected"]
    pub bAutodetectAddress: u8,
    #[doc = "< the physical address of the CEC adapter"]
    pub iPhysicalAddress: u16,
    #[doc = "< the logical address of the device to which the adapter is connected. only used when iPhysicalAddress = 0 or when the adapter doesn't support autodetection"]
    pub baseDevice: cec_logical_address,
    #[doc = "< the HDMI port to which the adapter is connected. only used when iPhysicalAddress = 0 or when the adapter doesn't support autodetection"]
    pub iHDMIPort: u8,
    #[doc = "< override the vendor ID of the TV. leave this untouched to autodetect"]
    pub tvVendor: u32,
    #[doc = "< list of devices to wake when initialising libCEC or when calling PowerOnDevices() without any parameter."]
    pub wakeDevices: cec_logical_addresses,
    #[doc = "< list of devices to power off when calling StandbyDevices() without any parameter."]
    pub powerOffDevices: cec_logical_addresses,
    #[doc = "< the version number of the server. read-only"]
    pub serverVersion: u32,
    #[doc = "< true to get the settings from the ROM (if set, and a v2 ROM is present), false to use these settings."]
    pub bGetSettingsFromROM: u8,
    #[doc = "< make libCEC the active source on the bus when starting the player application"]
    pub bActivateSource: u8,
    #[doc = "< put this PC in standby mode when the TV is switched off. only used when bShutdownOnStandby = 0"]
    pub bPowerOffOnStandby: u8,
    #[doc = "< the object to pass along with a call of the callback methods. NULL to ignore"]
    pub callbackParam: *mut ::std::os::raw::c_void,
    #[doc = "< the callback methods to use. set this to NULL when not using callbacks"]
    pub callbacks: *mut ICECCallbacks,
    #[doc = "< (read-only) the current logical addresses. added in 1.5.3"]
    pub logicalAddresses: cec_logical_addresses,
    #[doc = "< (read-only) the firmware version of the adapter. added in 1.6.0"]
    pub iFirmwareVersion: u16,
    #[doc = "< the menu language used by the client. 3 character ISO 639-2 country code. see http://http://www.loc.gov/standards/iso639-2/ added in 1.6.2"]
    pub strDeviceLanguage: [::std::os::raw::c_char; 3usize],
    #[doc = "< (read-only) the build date of the firmware, in seconds since epoch. if not available, this value will be set to 0. added in 1.6.2"]
    pub iFirmwareBuildDate: u32,
    #[doc = "< won't allocate a CCECClient when starting the connection when set (same as monitor mode). added in 1.6.3"]
    pub bMonitorOnly: u8,
    #[doc = "< CEC spec version to use by libCEC. defaults to v1.4. added in 1.8.0"]
    pub cecVersion: cec_version,
    #[doc = "< type of the CEC adapter that we're connected to. added in 1.8.2"]
    pub adapterType: cec_adapter_type,
    #[doc = "< key code that initiates combo keys. defaults to CEC_USER_CONTROL_CODE_F1_BLUE. CEC_USER_CONTROL_CODE_UNKNOWN to disable. added in 2.0.5"]
    pub comboKey: cec_user_control_code,
    #[doc = "< timeout until the combo key is sent as normal keypress"]
    pub iComboKeyTimeoutMs: u32,
    #[doc = "< rate at which buttons autorepeat. 0 means rely on CEC device"]
    pub iButtonRepeatRateMs: u32,
    #[doc = "< duration after last update until a button is considered released"]
    pub iButtonReleaseDelayMs: u32,
    #[doc = "< prevent double taps within this timeout. defaults to 200ms. added in 4.0.0"]
    pub iDoubleTapTimeoutMs: u32,
    #[doc = "< set to 1 to automatically waking an AVR when the source is activated. added in 4.0.0"]
    pub bAutoWakeAVR: u8,
}
pub const CEC_LIB_VERSION_MAJOR: u32 = 4;
pub const CEC_LIB_VERSION_MAJOR_STR: &[u8; 2] = b"4\0";
pub const CEC_LIB_VERSION_MINOR: u32 = 0;
pub const CEC_DEFAULT_PHYSICAL_ADDRESS: u32 = 4096;
pub const CEC_DEFAULT_HDMI_PORT: u32 = 1;
pub const CEC_DEFAULT_BASE_DEVICE: u32 = 0;
pub const CEC_BUTTON_TIMEOUT: u32 = 500;
pub const CEC_DOUBLE_TAP_TIMEOUT_MS: u32 = 200;
pub const CEC_POWER_STATE_REFRESH_TIME: u32 = 30000;
pub const CEC_FW_VERSION_UNKNOWN: u32 = 65535;
pub const CEC_FW_BUILD_UNKNOWN: u32 = 0;
pub const CEC_CONNECT_TRIES: u32 = 3;
pub const CEC_PHYSICAL_ADDRESS_TV: u32 = 0;
pub const CEC_MIN_PHYSICAL_ADDRESS: u32 = 4096;
pub const CEC_MAX_PHYSICAL_ADDRESS: u32 = 65534;
pub const CEC_INVALID_PHYSICAL_ADDRESS: u32 = 65535;
pub const CEC_MIN_VENDORID: u32 = 1;
pub const CEC_MAX_VENDORID: u32 = 16777214;
pub const CEC_INVALID_VENDORID: u32 = 16777215;
pub const CEC_MIN_HDMI_PORTNUMBER: u32 = 1;
pub const CEC_MAX_HDMI_PORTNUMBER: u32 = 15;
pub const CEC_HDMI_PORTNUMBER_NONE: u32 = 0;
pub const CEC_DEFAULT_SETTING_ACTIVATE_SOURCE: u32 = 1;
pub const CEC_DEFAULT_SETTING_POWER_OFF_SHUTDOWN: u32 = 1;
pub const CEC_DEFAULT_SETTING_POWER_OFF_ON_STANDBY: u32 = 1;
pub const CEC_DEFAULT_DEVICE_LANGUAGE: &[u8; 4] = b"eng\0";
pub const CEC_DEFAULT_SETTING_AUTODETECT_ADDRESS: u32 = 0;
pub const CEC_DEFAULT_SETTING_GET_SETTINGS_FROM_ROM: u32 = 0;
pub const CEC_DEFAULT_SETTING_CEC_VERSION: u32 = 5;
pub const CEC_DEFAULT_TRANSMIT_RETRY_WAIT: u32 = 500;
pub const CEC_DEFAULT_TRANSMIT_TIMEOUT: u32 = 1000;
pub const CEC_DEFAULT_TRANSMIT_WAIT: u32 = 1000;
pub const CEC_DEFAULT_TRANSMIT_RETRIES: u32 = 1;
pub const CEC_DEFAULT_CONNECT_TIMEOUT: u32 = 10000;
pub const CEC_DEFAULT_CONNECT_RETRY_WAIT: u32 = 1000;
pub const CEC_SERIAL_DEFAULT_BAUDRATE: u32 = 38400;
pub const CEC_CLEAR_INPUT_DEFAULT_WAIT: u32 = 1000;
pub const CEC_ACTIVE_SOURCE_SWITCH_RETRY_TIME_MS: u32 = 1000;
pub const CEC_FORWARD_STANDBY_MIN_INTERVAL: u32 = 10000;
pub const CEC_DEFAULT_COMBO_TIMEOUT_MS: u32 = 1000;
pub const CEC_RPI_VIRTUAL_PATH: &[u8; 13] = b"Raspberry Pi\0";
pub const CEC_RPI_VIRTUAL_COM: &[u8; 4] = b"RPI\0";
pub const CEC_TDA995x_PATH: &[u8; 13] = b"/dev/hdmicec\0";
pub const CEC_TDA995x_VIRTUAL_COM: &[u8; 6] = b"CuBox\0";
pub const CEC_EXYNOS_PATH: &[u8; 9] = b"/dev/CEC\0";
pub const CEC_EXYNOS_VIRTUAL_COM: &[u8; 7] = b"Exynos\0";
pub const CEC_MAX_DATA_PACKET_SIZE: u32 = 64;
pub const CEC_LINUX_PATH: &[u8; 10] = b"/dev/cec0\0";
pub const CEC_LINUX_VIRTUAL_COM: &[u8; 6] = b"Linux\0";
pub const CEC_AOCEC_PATH: &[u8; 11] = b"/dev/aocec\0";
pub const CEC_AOCEC_VIRTUAL_COM: &[u8; 6] = b"AOCEC\0";
pub const CEC_IMX_PATH: &[u8; 18] = b"/dev/mxc_hdmi_cec\0";
pub const CEC_IMX_VIRTUAL_COM: &[u8; 5] = b"i.MX\0";
pub const CEC_MIN_LIB_VERSION: u32 = 4;
pub const CEC_FEATURE_CONFIGURABLE_COMBO_KEY: u32 = 1;
pub const LIBCEC_OSD_NAME_SIZE: u32 = 13;
#[test]
fn bindgen_test_layout_cec_log_message() {
    const UNINIT: ::std::mem::MaybeUninit<cec_log_message> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cec_log_message>(),
        24usize,
        concat!("Size of: ", stringify!(cec_log_message))
    );
    assert_eq!(
        ::std::mem::align_of::<cec_log_message>(),
        8usize,
        concat!("Alignment of ", stringify!(cec_log_message))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).message) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_log_message),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_log_message),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_log_message),
            "::",
            stringify!(time)
        )
    );
}
#[test]
fn bindgen_test_layout_cec_keypress() {
    const UNINIT: ::std::mem::MaybeUninit<cec_keypress> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cec_keypress>(),
        8usize,
        concat!("Size of: ", stringify!(cec_keypress))
    );
    assert_eq!(
        ::std::mem::align_of::<cec_keypress>(),
        4usize,
        concat!("Alignment of ", stringify!(cec_keypress))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keycode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_keypress),
            "::",
            stringify!(keycode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duration) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_keypress),
            "::",
            stringify!(duration)
        )
    );
}
#[test]
fn bindgen_test_layout_cec_adapter() {
    const UNINIT: ::std::mem::MaybeUninit<cec_adapter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cec_adapter>(),
        2048usize,
        concat!("Size of: ", stringify!(cec_adapter))
    );
    assert_eq!(
        ::std::mem::align_of::<cec_adapter>(),
        1usize,
        concat!("Alignment of ", stringify!(cec_adapter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_adapter),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).comm) as usize - ptr as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_adapter),
            "::",
            stringify!(comm)
        )
    );
}
#[test]
fn bindgen_test_layout_cec_adapter_descriptor() {
    const UNINIT: ::std::mem::MaybeUninit<cec_adapter_descriptor> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cec_adapter_descriptor>(),
        2064usize,
        concat!("Size of: ", stringify!(cec_adapter_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<cec_adapter_descriptor>(),
        4usize,
        concat!("Alignment of ", stringify!(cec_adapter_descriptor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strComPath) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_adapter_descriptor),
            "::",
            stringify!(strComPath)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strComName) as usize - ptr as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_adapter_descriptor),
            "::",
            stringify!(strComName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iVendorId) as usize - ptr as usize },
        2048usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_adapter_descriptor),
            "::",
            stringify!(iVendorId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iProductId) as usize - ptr as usize },
        2050usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_adapter_descriptor),
            "::",
            stringify!(iProductId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iFirmwareVersion) as usize - ptr as usize },
        2052usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_adapter_descriptor),
            "::",
            stringify!(iFirmwareVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iPhysicalAddress) as usize - ptr as usize },
        2054usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_adapter_descriptor),
            "::",
            stringify!(iPhysicalAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iFirmwareBuildDate) as usize - ptr as usize },
        2056usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_adapter_descriptor),
            "::",
            stringify!(iFirmwareBuildDate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).adapterType) as usize - ptr as usize },
        2060usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_adapter_descriptor),
            "::",
            stringify!(adapterType)
        )
    );
}
#[test]
fn bindgen_test_layout_cec_datapacket() {
    const UNINIT: ::std::mem::MaybeUninit<cec_datapacket> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cec_datapacket>(),
        65usize,
        concat!("Size of: ", stringify!(cec_datapacket))
    );
    assert_eq!(
        ::std::mem::align_of::<cec_datapacket>(),
        1usize,
        concat!("Alignment of ", stringify!(cec_datapacket))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_datapacket),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_datapacket),
            "::",
            stringify!(size)
        )
    );
}
#[test]
fn bindgen_test_layout_cec_command() {
    const UNINIT: ::std::mem::MaybeUninit<cec_command> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cec_command>(),
        88usize,
        concat!("Size of: ", stringify!(cec_command))
    );
    assert_eq!(
        ::std::mem::align_of::<cec_command>(),
        4usize,
        concat!("Alignment of ", stringify!(cec_command))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initiator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_command),
            "::",
            stringify!(initiator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destination) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_command),
            "::",
            stringify!(destination)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_command),
            "::",
            stringify!(ack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eom) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_command),
            "::",
            stringify!(eom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opcode) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_command),
            "::",
            stringify!(opcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parameters) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_command),
            "::",
            stringify!(parameters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opcode_set) as usize - ptr as usize },
        81usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_command),
            "::",
            stringify!(opcode_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transmit_timeout) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_command),
            "::",
            stringify!(transmit_timeout)
        )
    );
}
#[test]
fn bindgen_test_layout_cec_device_type_list() {
    const UNINIT: ::std::mem::MaybeUninit<cec_device_type_list> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cec_device_type_list>(),
        20usize,
        concat!("Size of: ", stringify!(cec_device_type_list))
    );
    assert_eq!(
        ::std::mem::align_of::<cec_device_type_list>(),
        4usize,
        concat!("Alignment of ", stringify!(cec_device_type_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).types) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_device_type_list),
            "::",
            stringify!(types)
        )
    );
}
#[test]
fn bindgen_test_layout_cec_logical_addresses() {
    const UNINIT: ::std::mem::MaybeUninit<cec_logical_addresses> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cec_logical_addresses>(),
        68usize,
        concat!("Size of: ", stringify!(cec_logical_addresses))
    );
    assert_eq!(
        ::std::mem::align_of::<cec_logical_addresses>(),
        4usize,
        concat!("Alignment of ", stringify!(cec_logical_addresses))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).primary) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_logical_addresses),
            "::",
            stringify!(primary)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addresses) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_logical_addresses),
            "::",
            stringify!(addresses)
        )
    );
}
#[test]
fn bindgen_test_layout_libcec_parameter() {
    const UNINIT: ::std::mem::MaybeUninit<libcec_parameter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<libcec_parameter>(),
        16usize,
        concat!("Size of: ", stringify!(libcec_parameter))
    );
    assert_eq!(
        ::std::mem::align_of::<libcec_parameter>(),
        8usize,
        concat!("Alignment of ", stringify!(libcec_parameter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).paramType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_parameter),
            "::",
            stringify!(paramType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).paramData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_parameter),
            "::",
            stringify!(paramData)
        )
    );
}
#[test]
fn bindgen_test_layout_cec_adapter_stats() {
    const UNINIT: ::std::mem::MaybeUninit<cec_adapter_stats> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cec_adapter_stats>(),
        20usize,
        concat!("Size of: ", stringify!(cec_adapter_stats))
    );
    assert_eq!(
        ::std::mem::align_of::<cec_adapter_stats>(),
        4usize,
        concat!("Alignment of ", stringify!(cec_adapter_stats))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_ack) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_adapter_stats),
            "::",
            stringify!(tx_ack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_nack) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_adapter_stats),
            "::",
            stringify!(tx_nack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_error) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_adapter_stats),
            "::",
            stringify!(tx_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_total) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_adapter_stats),
            "::",
            stringify!(rx_total)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_error) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cec_adapter_stats),
            "::",
            stringify!(rx_error)
        )
    );
}
#[test]
fn bindgen_test_layout_ICECCallbacks() {
    const UNINIT: ::std::mem::MaybeUninit<ICECCallbacks> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ICECCallbacks>(),
        56usize,
        concat!("Size of: ", stringify!(ICECCallbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<ICECCallbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(ICECCallbacks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logMessage) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ICECCallbacks),
            "::",
            stringify!(logMessage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keyPress) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ICECCallbacks),
            "::",
            stringify!(keyPress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).commandReceived) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ICECCallbacks),
            "::",
            stringify!(commandReceived)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).configurationChanged) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ICECCallbacks),
            "::",
            stringify!(configurationChanged)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alert) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ICECCallbacks),
            "::",
            stringify!(alert)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).menuStateChanged) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ICECCallbacks),
            "::",
            stringify!(menuStateChanged)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sourceActivated) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ICECCallbacks),
            "::",
            stringify!(sourceActivated)
        )
    );
}
#[test]
fn bindgen_test_layout_libcec_configuration() {
    const UNINIT: ::std::mem::MaybeUninit<libcec_configuration> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<libcec_configuration>(),
        336usize,
        concat!("Size of: ", stringify!(libcec_configuration))
    );
    assert_eq!(
        ::std::mem::align_of::<libcec_configuration>(),
        8usize,
        concat!("Alignment of ", stringify!(libcec_configuration))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clientVersion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(clientVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strDeviceName) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(strDeviceName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deviceTypes) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(deviceTypes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bAutodetectAddress) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(bAutodetectAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iPhysicalAddress) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(iPhysicalAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).baseDevice) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(baseDevice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iHDMIPort) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(iHDMIPort)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tvVendor) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(tvVendor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wakeDevices) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(wakeDevices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).powerOffDevices) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(powerOffDevices)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverVersion) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(serverVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bGetSettingsFromROM) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(bGetSettingsFromROM)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bActivateSource) as usize - ptr as usize },
        197usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(bActivateSource)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bPowerOffOnStandby) as usize - ptr as usize },
        198usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(bPowerOffOnStandby)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callbackParam) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(callbackParam)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callbacks) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(callbacks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logicalAddresses) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(logicalAddresses)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iFirmwareVersion) as usize - ptr as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(iFirmwareVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strDeviceLanguage) as usize - ptr as usize },
        286usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(strDeviceLanguage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iFirmwareBuildDate) as usize - ptr as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(iFirmwareBuildDate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bMonitorOnly) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(bMonitorOnly)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cecVersion) as usize - ptr as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(cecVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).adapterType) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(adapterType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).comboKey) as usize - ptr as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(comboKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iComboKeyTimeoutMs) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(iComboKeyTimeoutMs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iButtonRepeatRateMs) as usize - ptr as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(iButtonRepeatRateMs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iButtonReleaseDelayMs) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(iButtonReleaseDelayMs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iDoubleTapTimeoutMs) as usize - ptr as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(iDoubleTapTimeoutMs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bAutoWakeAVR) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(libcec_configuration),
            "::",
            stringify!(bAutoWakeAVR)
        )
    );
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cec_abort_reason {
    #[doc = "!< CEC_ABORT_REASON_UNRECOGNIZED_OPCODE"]
    UNRECOGNIZED_OPCODE = 0,
    #[doc = "!< CEC_ABORT_REASON_NOT_IN_CORRECT_MODE_TO_RESPOND"]
    NOT_IN_CORRECT_MODE_TO_RESPOND = 1,
    #[doc = "!< CEC_ABORT_REASON_CANNOT_PROVIDE_SOURCE"]
    CANNOT_PROVIDE_SOURCE = 2,
    #[doc = "!< CEC_ABORT_REASON_INVALID_OPERAND"]
    INVALID_OPERAND = 3,
    #[doc = "!< CEC_ABORT_REASON_REFUSED"]
    REFUSED = 4,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cec_analogue_broadcast_type {
    CABLE = 0,
    SATELLITE = 1,
    TERRESTIAL = 2,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cec_audio_rate {
    RATE_CONTROL_OFF = 0,
    STANDARD_RATE_100 = 1,
    FAST_RATE_MAX_101 = 2,
    SLOW_RATE_MIN_99 = 3,
    STANDARD_RATE_100_0 = 4,
    FAST_RATE_MAX_100_1 = 5,
    SLOW_RATE_MIN_99_9 = 6,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cec_audio_status {
    MUTE_STATUS_MASK = 128,
    VOLUME_STATUS_MASK = 127,
    VOLUME_MIN = 0,
    VOLUME_MAX = 100,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cec_boolean {
    CEC_FALSE = 0,
    CEC_TRUE = 1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cec_version {
    UNKNOWN = 0,
    _1_2 = 1,
    _1_2A = 2,
    _1_3 = 3,
    _1_3A = 4,
    _1_4 = 5,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cec_channel_identifier {
    CEC_CHANNEL_NUMBER_FORMAT_MASK = -67108864,
    CEC_1_PART_CHANNEL_NUMBER = 67108864,
    CEC_2_PART_CHANNEL_NUMBER = 134217728,
    CEC_MAJOR_CHANNEL_NUMBER_MASK = 67043328,
    CEC_MINOR_CHANNEL_NUMBER_MASK = 65535,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cec_deck_control_mode {
    SKIP_FORWARD_WIND = 1,
    SKIP_REVERSE_REWIND = 2,
    STOP = 3,
    EJECT = 4,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cec_deck_info {
    PLAY = 17,
    RECORD = 18,
    PLAY_REVERSE = 19,
    STILL = 20,
    SLOW = 21,
    SLOW_REVERSE = 22,
    FAST_FORWARD = 23,
    FAST_REVERSE = 24,
    NO_MEDIA = 25,
    STOP = 26,
    SKIP_FORWARD_WIND = 27,
    SKIP_REVERSE_REWIND = 28,
    INDEX_SEARCH_FORWARD = 29,
    INDEX_SEARCH_REVERSE = 30,
    OTHER_STATUS = 31,
    OTHER_STATUS_LG = 32,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cec_device_type {
    TV = 0,
    RECORDING_DEVICE = 1,
    RESERVED = 2,
    TUNER = 3,
    PLAYBACK_DEVICE = 4,
    AUDIO_SYSTEM = 5,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cec_display_control {
    DISPLAY_FOR_DEFAULT_TIME = 0,
    DISPLAY_UNTIL_CLEARED = 64,
    CLEAR_PREVIOUS_MESSAGE = 128,
    RESERVED_FOR_FUTURE_USE = 192,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cec_external_source_specifier {
    EXTERNAL_PLUG = 4,
    EXTERNAL_PHYSICAL_ADDRESS = 5,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cec_menu_request_type {
    ACTIVATE = 0,
    DEACTIVATE = 1,
    QUERY = 2,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cec_menu_state {
    ACTIVATED = 0,
    DEACTIVATED = 1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cec_play_mode {
    PLAY_FORWARD = 36,
    PLAY_REVERSE = 32,
    PLAY_STILL = 37,
    FAST_FORWARD_MIN_SPEED = 5,
    FAST_FORWARD_MEDIUM_SPEED = 6,
    FAST_FORWARD_MAX_SPEED = 7,
    FAST_REVERSE_MIN_SPEED = 9,
    FAST_REVERSE_MEDIUM_SPEED = 10,
    FAST_REVERSE_MAX_SPEED = 11,
    SLOW_FORWARD_MIN_SPEED = 21,
    SLOW_FORWARD_MEDIUM_SPEED = 22,
    SLOW_FORWARD_MAX_SPEED = 23,
    SLOW_REVERSE_MIN_SPEED = 25,
    SLOW_REVERSE_MEDIUM_SPEED = 26,
    SLOW_REVERSE_MAX_SPEED = 27,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cec_power_status {
    ON = 0,
    STANDBY = 1,
    IN_TRANSITION_STANDBY_TO_ON = 2,
    IN_TRANSITION_ON_TO_STANDBY = 3,
    UNKNOWN = 153,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cec_record_source_type {
    OWN_SOURCE = 1,
    DIGITAL_SERVICE = 2,
    ANALOGUE_SERVICE = 3,
    EXTERNAL_PLUS = 4,
    EXTERNAL_PHYSICAL_ADDRESS = 5,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cec_record_status_info {
    RECORDING_CURRENTLY_SELECTED_SOURCE = 1,
    RECORDING_DIGITAL_SERVICE = 2,
    RECORDING_ANALOGUE_SERVICE = 3,
    RECORDING_EXTERNAL_INPUT = 4,
    NO_RECORDING_UNABLE_TO_RECORD_DIGITAL_SERVICE = 5,
    NO_RECORDING_UNABLE_TO_RECORD_ANALOGUE_SERVICE = 6,
    NO_RECORDING_UNABLE_TO_SELECT_REQUIRED_SERVICE = 7,
    NO_RECORDING_INVALID_EXTERNAL_PLUG_NUMBER = 9,
    NO_RECORDING_INVALID_EXTERNAL_ADDRESS = 10,
    NO_RECORDING_CA_SYSTEM_NOT_SUPPORTED = 11,
    NO_RECORDING_NO_OR_INSUFFICIENT_ENTITLEMENTS = 12,
    NO_RECORDING_NOT_ALLOWED_TO_COPY_SOURCE = 13,
    NO_RECORDING_NO_FURTHER_COPIES_ALLOWED = 14,
    NO_RECORDING_NO_MEDIA = 16,
    NO_RECORDING_PLAYING = 17,
    NO_RECORDING_ALREADY_RECORDING = 18,
    NO_RECORDING_MEDIA_PROTECTED = 19,
    NO_RECORDING_NO_SOURCE_SIGNAL = 20,
    NO_RECORDING_MEDIA_PROBLEM = 21,
    NO_RECORDING_NOT_ENOUGH_SPACE_AVAILABLE = 22,
    NO_RECORDING_PARENTAL_LOCK_ON = 23,
    RECORDING_TERMINATED_NORMALLY = 26,
    RECORDING_HAS_ALREADY_TERMINATED = 27,
    NO_RECORDING_OTHER_REASON = 31,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cec_recording_sequence {
    SUNDAY = 1,
    MONDAY = 2,
    TUESDAY = 4,
    WEDNESDAY = 8,
    THURSDAY = 16,
    FRIDAY = 32,
    SATURDAY = 64,
    ONCE_ONLY = 0,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cec_status_request {
    ON = 1,
    OFF = 2,
    ONCE = 3,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cec_system_audio_status {
    OFF = 0,
    ON = 1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cec_timer_cleared_status_data {
    TIMER_NOT_CLEARED_RECORDING = 0,
    TIMER_NOT_CLEARED_NO_MATCHING = 1,
    TIMER_NOT_CLEARED_NO_INF0_AVAILABLE = 2,
    TIMER_CLEARED = 128,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cec_timer_overlap_warning {
    NO_OVERLAP = 0,
    TIMER_BLOCKS_OVERLAP = 1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cec_media_info {
    MEDIA_PRESENT_AND_NOT_PROTECTED = 0,
    MEDIA_PRESENT_BUT_PROTECTED = 1,
    MEDIA_NOT_PRESENT = 2,
    FUTURE_USE = 3,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cec_programmed_indicator {
    NOT_PROGRAMMED = 0,
    PROGRAMMED = 1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cec_programmed_info {
    FUTURE_USE = 0,
    ENOUGH_SPACE_AVAILABLE_FOR_RECORDING = 8,
    NOT_ENOUGH_SPACE_AVAILABLE_FOR_RECORDING = 9,
    MAY_NOT_BE_ENOUGH_SPACE_AVAILABLE = 11,
    NO_MEDIA_INFO_AVAILABLE = 10,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cec_not_programmed_error_info {
    FUTURE_USE = 0,
    NO_FREE_TIMER_AVAILABLE = 1,
    DATE_OUT_OF_RANGE = 2,
    RECORDING_SEQUENCE_ERROR = 3,
    INVALID_EXTERNAL_PLUG_NUMBER = 4,
    INVALID_EXTERNAL_PHYSICAL_ADDRESS = 5,
    CA_SYSTEM_NOT_SUPPORTED = 6,
    NO_OR_INSUFFICIENT_CA_ENTITLEMENTS = 7,
    DOES_NOT_SUPPORT_RESOLUTION = 8,
    PARENTAL_LOCK_ON = 9,
    CLOCK_FAILURE = 10,
    RESERVED_FOR_FUTURE_USE_START = 11,
    RESERVED_FOR_FUTURE_USE_END = 13,
    DUPLICATE_ALREADY_PROGRAMMED = 14,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cec_recording_flag {
    NOT_BEING_USED_FOR_RECORDING = 0,
    BEING_USED_FOR_RECORDING = 1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cec_tuner_display_info {
    DISPLAYING_DIGITAL_TUNER = 0,
    NOT_DISPLAYING_TUNER = 1,
    DISPLAYING_ANALOGUE_TUNER = 2,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cec_broadcast_system {
    PAL_B_G = 0,
    SECAM_L1 = 1,
    PAL_M = 2,
    NTSC_M = 3,
    PAL_I = 4,
    SECAM_DK = 5,
    SECAM_B_G = 6,
    SECAM_L2 = 7,
    PAL_DK = 8,
    OTHER_SYSTEM = 30,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cec_user_control_code {
    SELECT = 0,
    UP = 1,
    DOWN = 2,
    LEFT = 3,
    RIGHT = 4,
    RIGHT_UP = 5,
    RIGHT_DOWN = 6,
    LEFT_UP = 7,
    LEFT_DOWN = 8,
    ROOT_MENU = 9,
    SETUP_MENU = 10,
    CONTENTS_MENU = 11,
    FAVORITE_MENU = 12,
    EXIT = 13,
    TOP_MENU = 16,
    DVD_MENU = 17,
    NUMBER_ENTRY_MODE = 29,
    NUMBER11 = 30,
    NUMBER12 = 31,
    NUMBER0 = 32,
    NUMBER1 = 33,
    NUMBER2 = 34,
    NUMBER3 = 35,
    NUMBER4 = 36,
    NUMBER5 = 37,
    NUMBER6 = 38,
    NUMBER7 = 39,
    NUMBER8 = 40,
    NUMBER9 = 41,
    DOT = 42,
    ENTER = 43,
    CLEAR = 44,
    NEXT_FAVORITE = 47,
    CHANNEL_UP = 48,
    CHANNEL_DOWN = 49,
    PREVIOUS_CHANNEL = 50,
    SOUND_SELECT = 51,
    INPUT_SELECT = 52,
    DISPLAY_INFORMATION = 53,
    HELP = 54,
    PAGE_UP = 55,
    PAGE_DOWN = 56,
    POWER = 64,
    VOLUME_UP = 65,
    VOLUME_DOWN = 66,
    MUTE = 67,
    PLAY = 68,
    STOP = 69,
    PAUSE = 70,
    RECORD = 71,
    REWIND = 72,
    FAST_FORWARD = 73,
    EJECT = 74,
    FORWARD = 75,
    BACKWARD = 76,
    STOP_RECORD = 77,
    PAUSE_RECORD = 78,
    ANGLE = 80,
    SUB_PICTURE = 81,
    VIDEO_ON_DEMAND = 82,
    ELECTRONIC_PROGRAM_GUIDE = 83,
    TIMER_PROGRAMMING = 84,
    INITIAL_CONFIGURATION = 85,
    SELECT_BROADCAST_TYPE = 86,
    SELECT_SOUND_PRESENTATION = 87,
    PLAY_FUNCTION = 96,
    PAUSE_PLAY_FUNCTION = 97,
    RECORD_FUNCTION = 98,
    PAUSE_RECORD_FUNCTION = 99,
    STOP_FUNCTION = 100,
    MUTE_FUNCTION = 101,
    RESTORE_VOLUME_FUNCTION = 102,
    TUNE_FUNCTION = 103,
    SELECT_MEDIA_FUNCTION = 104,
    SELECT_AV_INPUT_FUNCTION = 105,
    SELECT_AUDIO_INPUT_FUNCTION = 106,
    POWER_TOGGLE_FUNCTION = 107,
    POWER_OFF_FUNCTION = 108,
    POWER_ON_FUNCTION = 109,
    F1_BLUE = 113,
    F2_RED = 114,
    F3_GREEN = 115,
    F4_YELLOW = 116,
    F5 = 117,
    DATA = 118,
    AN_RETURN = 145,
    AN_CHANNELS_LIST = 150,
    UNKNOWN = 255,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cec_logical_address {
    UNKNOWN = -1,
    TV = 0,
    RECORDINGDEVICE1 = 1,
    RECORDINGDEVICE2 = 2,
    TUNER1 = 3,
    PLAYBACKDEVICE1 = 4,
    AUDIOSYSTEM = 5,
    TUNER2 = 6,
    TUNER3 = 7,
    PLAYBACKDEVICE2 = 8,
    RECORDINGDEVICE3 = 9,
    TUNER4 = 10,
    PLAYBACKDEVICE3 = 11,
    RESERVED1 = 12,
    RESERVED2 = 13,
    FREEUSE = 14,
    UNREGISTERED = 15,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cec_opcode {
    ACTIVE_SOURCE = 130,
    IMAGE_VIEW_ON = 4,
    TEXT_VIEW_ON = 13,
    INACTIVE_SOURCE = 157,
    REQUEST_ACTIVE_SOURCE = 133,
    ROUTING_CHANGE = 128,
    ROUTING_INFORMATION = 129,
    SET_STREAM_PATH = 134,
    STANDBY = 54,
    RECORD_OFF = 11,
    RECORD_ON = 9,
    RECORD_STATUS = 10,
    RECORD_TV_SCREEN = 15,
    CLEAR_ANALOGUE_TIMER = 51,
    CLEAR_DIGITAL_TIMER = 153,
    CLEAR_EXTERNAL_TIMER = 161,
    SET_ANALOGUE_TIMER = 52,
    SET_DIGITAL_TIMER = 151,
    SET_EXTERNAL_TIMER = 162,
    SET_TIMER_PROGRAM_TITLE = 103,
    TIMER_CLEARED_STATUS = 67,
    TIMER_STATUS = 53,
    CEC_VERSION = 158,
    GET_CEC_VERSION = 159,
    GIVE_PHYSICAL_ADDRESS = 131,
    GET_MENU_LANGUAGE = 145,
    REPORT_PHYSICAL_ADDRESS = 132,
    SET_MENU_LANGUAGE = 50,
    DECK_CONTROL = 66,
    DECK_STATUS = 27,
    GIVE_DECK_STATUS = 26,
    PLAY = 65,
    GIVE_TUNER_DEVICE_STATUS = 8,
    SELECT_ANALOGUE_SERVICE = 146,
    SELECT_DIGITAL_SERVICE = 147,
    TUNER_DEVICE_STATUS = 7,
    TUNER_STEP_DECREMENT = 6,
    TUNER_STEP_INCREMENT = 5,
    DEVICE_VENDOR_ID = 135,
    GIVE_DEVICE_VENDOR_ID = 140,
    VENDOR_COMMAND = 137,
    VENDOR_COMMAND_WITH_ID = 160,
    VENDOR_REMOTE_BUTTON_DOWN = 138,
    VENDOR_REMOTE_BUTTON_UP = 139,
    SET_OSD_STRING = 100,
    GIVE_OSD_NAME = 70,
    SET_OSD_NAME = 71,
    MENU_REQUEST = 141,
    MENU_STATUS = 142,
    USER_CONTROL_PRESSED = 68,
    USER_CONTROL_RELEASE = 69,
    GIVE_DEVICE_POWER_STATUS = 143,
    REPORT_POWER_STATUS = 144,
    FEATURE_ABORT = 0,
    ABORT = 255,
    GIVE_AUDIO_STATUS = 113,
    GIVE_SYSTEM_AUDIO_MODE_STATUS = 125,
    REPORT_AUDIO_STATUS = 122,
    SET_SYSTEM_AUDIO_MODE = 114,
    SYSTEM_AUDIO_MODE_REQUEST = 112,
    SYSTEM_AUDIO_MODE_STATUS = 126,
    SET_AUDIO_RATE = 154,
    REPORT_SHORT_AUDIO_DESCRIPTORS = 163,
    REQUEST_SHORT_AUDIO_DESCRIPTORS = 164,
    START_ARC = 192,
    REPORT_ARC_STARTED = 193,
    REPORT_ARC_ENDED = 194,
    REQUEST_ARC_START = 195,
    REQUEST_ARC_END = 196,
    END_ARC = 197,
    CDC = 248,
    NONE = 253,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cec_log_level {
    CEC_LOG_ERROR = 1,
    CEC_LOG_WARNING = 2,
    CEC_LOG_NOTICE = 4,
    CEC_LOG_TRAFFIC = 8,
    CEC_LOG_DEBUG = 16,
    CEC_LOG_ALL = 31,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cec_bus_device_status {
    UNKNOWN = 0,
    PRESENT = 1,
    NOT_PRESENT = 2,
    HANDLED_BY_LIBCEC = 3,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cec_vendor_id {
    TOSHIBA = 57,
    SAMSUNG = 240,
    DENON = 1485,
    MARANTZ = 1656,
    LOEWE = 2434,
    ONKYO = 2480,
    MEDION = 3256,
    TOSHIBA2 = 3303,
    APPLE = 4346,
    PULSE_EIGHT = 5506,
    HARMAN_KARDON2 = 6480,
    GOOGLE = 6673,
    AKAI = 8391,
    AOC = 9319,
    PANASONIC = 32837,
    PHILIPS = 36926,
    DAEWOO = 36947,
    YAMAHA = 41182,
    GRUNDIG = 53461,
    PIONEER = 57398,
    LG = 57489,
    SHARP = 524319,
    SONY = 524358,
    BROADCOM = 1622150,
    SHARP2 = 5458000,
    VIZIO = 7042157,
    BENQ = 8414697,
    HARMAN_KARDON = 10249310,
    UNKNOWN = 0,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cec_adapter_type {
    UNKNOWN = 0,
    P8_EXTERNAL = 1,
    P8_DAUGHTERBOARD = 2,
    RPI = 256,
    TDA995x = 512,
    EXYNOS = 768,
    LINUX = 1024,
    AOCEC = 1280,
    IMX = 1536,
}
#[repr(i32)]
#[doc = " force exporting through swig"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum libcec_version {
    CURRENT = 262149,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum libcec_alert {
    SERVICE_DEVICE = 0,
    CONNECTION_LOST = 1,
    PERMISSION_ERROR = 2,
    PORT_BUSY = 3,
    PHYSICAL_ADDRESS_ERROR = 4,
    TV_POLL_FAILED = 5,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum libcec_parameter_type {
    STRING = 0,
    UNKOWN = 1,
}
impl cec_audio_status {
    pub const VOLUME_STATUS_UNKNOWN: cec_audio_status = cec_audio_status::VOLUME_STATUS_MASK;
}
impl cec_user_control_code {
    pub const MAX: cec_user_control_code = cec_user_control_code::AN_CHANNELS_LIST;
}
impl cec_logical_address {
    pub const BROADCAST: cec_logical_address = cec_logical_address::UNREGISTERED;
}
impl Default for cec_log_message {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for cec_keypress {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for cec_adapter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for cec_adapter_descriptor {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for cec_datapacket {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for cec_command {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for cec_device_type_list {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for cec_logical_addresses {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for libcec_parameter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for libcec_configuration {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn libcec_initialise(configuration: *mut libcec_configuration) -> libcec_connection_t;
    pub fn libcec_destroy(connection: libcec_connection_t);
    pub fn libcec_open(
        connection: libcec_connection_t,
        strPort: *const ::std::os::raw::c_char,
        iTimeout: u32,
    ) -> ::std::os::raw::c_int;
    pub fn libcec_close(connection: libcec_connection_t);
    pub fn libcec_clear_configuration(configuration: *mut libcec_configuration);
    pub fn libcec_enable_callbacks(
        connection: libcec_connection_t,
        cbParam: *mut ::std::os::raw::c_void,
        callbacks: *mut ICECCallbacks,
    ) -> ::std::os::raw::c_int;
    pub fn libcec_find_adapters(
        connection: libcec_connection_t,
        deviceList: *mut cec_adapter,
        iBufSize: u8,
        strDevicePath: *const ::std::os::raw::c_char,
    ) -> i8;
    pub fn libcec_ping_adapters(connection: libcec_connection_t) -> ::std::os::raw::c_int;
    pub fn libcec_start_bootloader(connection: libcec_connection_t) -> ::std::os::raw::c_int;
    pub fn libcec_power_on_devices(
        connection: libcec_connection_t,
        address: cec_logical_address,
    ) -> ::std::os::raw::c_int;
    pub fn libcec_standby_devices(
        connection: libcec_connection_t,
        address: cec_logical_address,
    ) -> ::std::os::raw::c_int;
    pub fn libcec_set_active_source(
        connection: libcec_connection_t,
        type_: cec_device_type,
    ) -> ::std::os::raw::c_int;
    pub fn libcec_set_deck_control_mode(
        connection: libcec_connection_t,
        mode: cec_deck_control_mode,
        bSendUpdate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn libcec_set_deck_info(
        connection: libcec_connection_t,
        info: cec_deck_info,
        bSendUpdate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn libcec_set_inactive_view(connection: libcec_connection_t) -> ::std::os::raw::c_int;
    pub fn libcec_set_menu_state(
        connection: libcec_connection_t,
        state: cec_menu_state,
        bSendUpdate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn libcec_transmit(
        connection: libcec_connection_t,
        data: *const cec_command,
    ) -> ::std::os::raw::c_int;
    pub fn libcec_set_logical_address(
        connection: libcec_connection_t,
        iLogicalAddress: cec_logical_address,
    ) -> ::std::os::raw::c_int;
    pub fn libcec_set_physical_address(
        connection: libcec_connection_t,
        iPhysicalAddress: u16,
    ) -> ::std::os::raw::c_int;
    pub fn libcec_set_osd_string(
        connection: libcec_connection_t,
        iLogicalAddress: cec_logical_address,
        duration: cec_display_control,
        strMessage: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn libcec_switch_monitoring(
        connection: libcec_connection_t,
        bEnable: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn libcec_get_device_cec_version(
        connection: libcec_connection_t,
        iLogicalAddress: cec_logical_address,
    ) -> cec_version;
    pub fn libcec_get_device_menu_language(
        connection: libcec_connection_t,
        iLogicalAddress: cec_logical_address,
        language: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn libcec_get_device_vendor_id(
        connection: libcec_connection_t,
        iLogicalAddress: cec_logical_address,
    ) -> u32;
    pub fn libcec_get_device_physical_address(
        connection: libcec_connection_t,
        iLogicalAddress: cec_logical_address,
    ) -> u16;
    pub fn libcec_get_active_source(connection: libcec_connection_t) -> cec_logical_address;
    pub fn libcec_is_active_source(
        connection: libcec_connection_t,
        iAddress: cec_logical_address,
    ) -> ::std::os::raw::c_int;
    pub fn libcec_get_device_power_status(
        connection: libcec_connection_t,
        iLogicalAddress: cec_logical_address,
    ) -> cec_power_status;
    pub fn libcec_poll_device(
        connection: libcec_connection_t,
        iLogicalAddress: cec_logical_address,
    ) -> ::std::os::raw::c_int;
    pub fn libcec_get_active_devices(connection: libcec_connection_t) -> cec_logical_addresses;
    pub fn libcec_is_active_device(
        connection: libcec_connection_t,
        address: cec_logical_address,
    ) -> ::std::os::raw::c_int;
    pub fn libcec_is_active_device_type(
        connection: libcec_connection_t,
        type_: cec_device_type,
    ) -> ::std::os::raw::c_int;
    pub fn libcec_set_hdmi_port(
        connection: libcec_connection_t,
        baseDevice: cec_logical_address,
        iPort: u8,
    ) -> ::std::os::raw::c_int;
    pub fn libcec_volume_up(
        connection: libcec_connection_t,
        bSendRelease: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn libcec_volume_down(
        connection: libcec_connection_t,
        bSendRelease: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn libcec_mute_audio(
        connection: libcec_connection_t,
        bSendRelease: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn libcec_send_keypress(
        connection: libcec_connection_t,
        iDestination: cec_logical_address,
        key: cec_user_control_code,
        bWait: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn libcec_send_key_release(
        connection: libcec_connection_t,
        iDestination: cec_logical_address,
        bWait: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    pub fn libcec_get_device_osd_name(
        connection: libcec_connection_t,
        iAddress: cec_logical_address,
        name: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    pub fn libcec_set_stream_path_logical(
        connection: libcec_connection_t,
        iAddress: cec_logical_address,
    ) -> ::std::os::raw::c_int;
    pub fn libcec_set_stream_path_physical(
        connection: libcec_connection_t,
        iPhysicalAddress: u16,
    ) -> ::std::os::raw::c_int;
    pub fn libcec_get_logical_addresses(connection: libcec_connection_t) -> cec_logical_addresses;
    pub fn libcec_get_current_configuration(
        connection: libcec_connection_t,
        configuration: *mut libcec_configuration,
    ) -> ::std::os::raw::c_int;
    pub fn libcec_can_persist_configuration(
        connection: libcec_connection_t,
    ) -> ::std::os::raw::c_int;
    pub fn libcec_persist_configuration(
        connection: libcec_connection_t,
        configuration: *mut libcec_configuration,
    ) -> ::std::os::raw::c_int;
    pub fn libcec_set_configuration(
        connection: libcec_connection_t,
        configuration: *const libcec_configuration,
    ) -> ::std::os::raw::c_int;
    pub fn libcec_rescan_devices(connection: libcec_connection_t);
    pub fn libcec_is_libcec_active_source(connection: libcec_connection_t)
        -> ::std::os::raw::c_int;
    pub fn libcec_get_device_information(
        connection: libcec_connection_t,
        strPort: *const ::std::os::raw::c_char,
        config: *mut libcec_configuration,
        iTimeoutMs: u32,
    ) -> ::std::os::raw::c_int;
    pub fn libcec_get_lib_info(connection: libcec_connection_t) -> *const ::std::os::raw::c_char;
    pub fn libcec_init_video_standalone(connection: libcec_connection_t);
    pub fn libcec_get_adapter_vendor_id(connection: libcec_connection_t) -> u16;
    pub fn libcec_get_adapter_product_id(connection: libcec_connection_t) -> u16;
    pub fn libcec_audio_toggle_mute(connection: libcec_connection_t) -> u8;
    pub fn libcec_audio_mute(connection: libcec_connection_t) -> u8;
    pub fn libcec_audio_unmute(connection: libcec_connection_t) -> u8;
    pub fn libcec_audio_get_status(connection: libcec_connection_t) -> u8;
    pub fn libcec_detect_adapters(
        connection: libcec_connection_t,
        deviceList: *mut cec_adapter_descriptor,
        iBufSize: u8,
        strDevicePath: *const ::std::os::raw::c_char,
        bQuickScan: ::std::os::raw::c_int,
    ) -> i8;
    pub fn libcec_menu_state_to_string(
        state: cec_menu_state,
        buf: *mut ::std::os::raw::c_char,
        bufsize: usize,
    );
    pub fn libcec_cec_version_to_string(
        version: cec_version,
        buf: *mut ::std::os::raw::c_char,
        bufsize: usize,
    );
    pub fn libcec_power_status_to_string(
        status: cec_power_status,
        buf: *mut ::std::os::raw::c_char,
        bufsize: usize,
    );
    pub fn libcec_logical_address_to_string(
        address: cec_logical_address,
        buf: *mut ::std::os::raw::c_char,
        bufsize: usize,
    );
    pub fn libcec_deck_control_mode_to_string(
        mode: cec_deck_control_mode,
        buf: *mut ::std::os::raw::c_char,
        bufsize: usize,
    );
    pub fn libcec_deck_status_to_string(
        status: cec_deck_info,
        buf: *mut ::std::os::raw::c_char,
        bufsize: usize,
    );
    pub fn libcec_opcode_to_string(
        opcode: cec_opcode,
        buf: *mut ::std::os::raw::c_char,
        bufsize: usize,
    );
    pub fn libcec_system_audio_status_to_string(
        mode: cec_system_audio_status,
        buf: *mut ::std::os::raw::c_char,
        bufsize: usize,
    );
    pub fn libcec_audio_status_to_string(
        status: cec_audio_status,
        buf: *mut ::std::os::raw::c_char,
        bufsize: usize,
    );
    pub fn libcec_vendor_id_to_string(
        vendor: cec_vendor_id,
        buf: *mut ::std::os::raw::c_char,
        bufsize: usize,
    );
    pub fn libcec_user_control_key_to_string(
        key: cec_user_control_code,
        buf: *mut ::std::os::raw::c_char,
        bufsize: usize,
    );
    pub fn libcec_adapter_type_to_string(
        type_: cec_adapter_type,
        buf: *mut ::std::os::raw::c_char,
        bufsize: usize,
    );
    pub fn libcec_version_to_string(version: u32, buf: *mut ::std::os::raw::c_char, bufsize: usize);
}
